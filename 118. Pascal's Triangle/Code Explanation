# Problem Explanation

## 118. Pascal's Triangle

### Step 1: Understand the Problem

- **Input:** An integer `numRows`.
- **Output:** A list of lists representing the first `numRows` of Pascal's Triangle.
- **Definition:** In Pascal's Triangle:
    1. The first row is always `[1]`.
    2. Each subsequent row is constructed by summing adjacent elements from the previous row.
    3. Each row starts and ends with `1`.

### Step 2: Work Through Examples

- **Example 1:** `numRows = 5`
    - Row 1: `[1]`
    - Row 2: `[1, 1]` (1+0, 0+1)
    - Row 3: `[1, 2, 1]` (1+0, 1+1, 1+0)
    - Row 4: `[1, 3, 3, 1]`
    - Row 5: `[1, 4, 6, 4, 1]`
    - **Output:** `[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]`

### Step 3: Identify the Problem Type

- **Dynamic Programming:** The value of the current state depends on the previous state.
- **Array Manipulation:** Specifically, generating lists based on mathematical rules.

### Step 4: Think About Approaches

1. **Mathematical Formula ($nCk$):** You can calculate every element using combinatorics ($n$ choose $k$).
    - *Drawback:* Calculating factorials for every element is computationally expensive and hard to implement cleanly.
2. **Iterative Simulation (The Solution):** Build the triangle row by row. To generate row `i`, look at row `i-1`.
    - *Challenge:* Handling the edges (the `1`s at the start and end).
    - *Trick:* The implemented solution uses a clever **Zero Padding** technique. By adding a `0` to the start and end of the previous row, the logic for the edges becomes identical to the middle elements.

### Step 5: Plan Before Coding

**Pseudocode:**

Plaintext

`function generate(numRows):
    // 1. Initialize with the first row
    res = [[1]]

    // 2. Loop to generate the remaining rows
    //    Run (numRows - 1) times
    For i from 0 to numRows - 2:
        
        // 3. Prepare the previous row with padding
        //    If prev row is [1], temp becomes [0, 1, 0]
        temp = [0] + last_row_in_res + [0]
        
        // 4. Build the new row
        new_row = []
        For j from 0 to length of last_row:
            // Sum the sliding window of 2 elements from temp
            sum = temp[j] + temp[j+1]
            new_row.append(sum)
            
        // 5. Add new row to results
        res.append(new_row)

    return res`

### Step 6: Consider Edge Cases

- `numRows = 1`: The loop `range(0)` does not run. Returns `[[1]]` correctly.
- `numRows = 2`: Loop runs once. `temp` becomes `[0, 1, 0]`. `row` becomes `[1, 1]`. Returns `[[1], [1, 1]]`. Correct.

### Step 7: Complexity Analysis

- **Time Complexity:** $O(N^2)$. We generate $1$ element, then $2$, then $3$... up to $N$. The total elements are $N(N+1)/2$.
- **Space Complexity:** $O(N^2)$ to store the output triangle.

### Step 8: Review and Reflect

- **Why does this work?** The core property of Pascal's triangle is $Val[i][j] = Val[i-1][j-1] + Val[i-1][j]$. Padding with zeros effectively treats "out of bounds" neighbors as 0, allowing us to use one simple formula for the whole row.

---

# Code Explanation

### The Analogy: The "Invisible Helper" Zeros

Imagine constructing a pyramid of blocks.

- To support the blocks on the edge (which only have one block below them diagonally), imagine **invisible zero-value blocks** floating in the air on the left and right sides.
- Now, every single block in the new row rests on exactly two blocks from the row below (one real, one potentially invisible/zero).

### Step 1: The Initialization

**Code:**

Python

`res = [[1]]
for i in range(numRows - 1):`

- **What it does:** We start with the tip of the triangle. If `numRows` is 5, we need to generate 4 more rows, so we loop `numRows - 1` times.

### Step 2: The Zero Padding (The Trick)

**Code:**

Python

    `temp = [0] + res[-1] + [0]`

- **What it does:** It takes the last completed row (`res[-1]`) and adds a `0` to the start and end.
- *Example:* If the last row was `[1, 2, 1]`, `temp` becomes `[0, 1, 2, 1, 0]`.
- This prepares us to calculate the sums easily. The length of `temp` is `len(last_row) + 2`.

### Step 3: The Sliding Window Sum

**Code:**

Python

    `row = []
    for j in range(len(res[-1]) + 1):
        row.append(temp[j] + temp[j + 1])
    res.append(row)`

- **What it does:** We iterate through `temp`, taking pairs of numbers and adding them.
- *Trace (using previous example `[0, 1, 2, 1, 0]`):*
    1. `j=0`: `temp[0] + temp[1]` -> `0 + 1 = 1`
    2. `j=1`: `temp[1] + temp[2]` -> `1 + 2 = 3`
    3. `j=2`: `temp[2] + temp[3]` -> `2 + 1 = 3`
    4. `j=3`: `temp[3] + temp[4]` -> `1 + 0 = 1`
- **Result:** `[1, 3, 3, 1]`. We successfully generated the next row without any complex index checking.

---

# Analysis Summary (Deep Revision Framework)

### The Core Idea:

The one-sentence summary is: **"We construct Pascal's Triangle row by row, using a temporary array padded with leading and trailing zeros (`[0] + row + [0]`) to simplify the summation logic for edge elements."**

### Data Structure Choice:

- **List of Lists:** Required format for the output.
- **Temp List:** Helper structure to handle boundary conditions gracefully.

### Algorithm Pattern:

- **Simulation / Dynamic Programming:** We build the solution for step $N$ based entirely on the solution for step $N-1$.
- **Padding Technique:** A common trick in grid/array problems (like convolution) to handle edges without `if` statements.

### Complexity:

- **Time:** $O(N^2)$.
- **Space:** $O(N^2)$.

### Articulate the Solution:

"I built the triangle iteratively. I initialized the result with [[1]]."

"For each subsequent row, I created a temporary array by adding a 0 to the beginning and end of the previous row."

"Then, I iterated through this temporary array, summing adjacent pairs (temp[j] + temp[j+1]) to generate the new values. This zero-padding technique correctly handles the 1s at the edges automatically."

### Spaced Repetition & Follow-ups:

- **LeetCode 119. Pascal's Triangle II:** Return *only* the $k$-th row. (Can you do it with $O(k)$ space? Yes, by updating the array in place).